1. Design Patterns

Reusable solution to a commonly occurring problem within a given context in software design. There are four wa
  * **Creational:** Creational patterns provide the capability to create objects based on a required criterion and in a controlled way
  Abstract Factory, Builder, Factory Method, Prototype, Singleton
  * **Structural:** Organizing different classes and objects to form larger structures and provide new functionality
  Adapter, Bridge, Facade ....
  * **Behavioral:** Identifying common communication patterns between objects and realize these patterns
  * Concurrency

2. Software Engineering Concepts
  * **Abstraction:**  Abstraction means using simple things to represent complexity. We all know how to turn the TV on, but we don’t need to know how it works in order to enjoy it. In Java, abstraction means simple things like objects, classes, and variables represent more complex underlying code and data.
  * **Encapsulation:** This is the practice of keeping fields within a class private, then providing access to them via public methods.
  * **Inheritance:** Create new classes that share some of the attributes of existing classes. This lets us build on previous work without reinventing the wheel.
  * **Polymorphism:** Same word to mean different things in different contexts. One form of polymorphism in Java is method overriding. That’s when different meanings are implied by the code itself. The other form is method overloading. That’s when the different meanings are implied by the values of the supplied variables

3. Software Development Life Cycle
 Major stages of an SDLC are Planning --> Requirements --> System Design --> Software Development --> Testing --> Deployment --> Operations & Maintenance 
 
 Common models are Waterfall, Agile and Iterative. In our organization, we were using Iterative cycle. This was adopted to cater the rapidly changing requirements of the client. 
 I was mainly involved in designing and development phases of the project. 
 
 We used to get requirements from the client, those requirements were then analyzed by the managers to decide which of them can be done in the next iteration along with the bug fixes. 
 Once the features to be developed and bugs to fix were decided, a design phase was started and in paralell testing team was asked to start working on the test cases for new features.
 In the design phase the new components' interaction with previously built components was also identified so that modular testing can cover those components with new components.
 For the development phase, a new branch was originated from the master for every new feature and developers used to start working on it. Once the development was done, unit tests
 and their results were kept in a file for reference. This branch was then tested by the testing team to find any bug fixes and if the tests are passed, this branch was merged with the master where a more detailed testing was done.
 
 
 
